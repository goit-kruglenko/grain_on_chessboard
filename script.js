var i, j = 1,
    t, total = 1,
    timerStart, timerStop, chessboardSize = 64,
    limit = 91480000,
    type_of,
    echo;

echo = "<h1>Легенда о шахматной доске</h1>";
echo += "<p></p>';
echo += "<h2>Сложение</h2>";

echo += "<p>Мне кажется, что это первое, что приходит в голову.</p>';


for (i = 1; i <= chessboardSize && j <= limit; i = i + 1) {
    j = j + j;
    total += j;
    echo += '<br>' + i + ') ' + j;
}

echo += "<p>Общая куча зерна: " + total + '</p>';

echo += "<p>Как известно, в JS нет отдельно выделеных <i>Integer</i> и <i>Float</i>,  их заменяет один общий тип  <i>Numeber</i>. Стандарт IEEE 754, которым руководствуется JS при хранении чисел, на <i>Number</i> выделяет 8 байт или 64 бита, из которых только 52 бита выделены целой части, 11 бит для хранения экспоненты. Тем не менее, точность сохраняется еще две итерации, и только к 55-му  шагу результат перестает быть «круглым» в шестнадцатиричном исчислении, набегают две единички: 80000000000002.</n>";

/****************************************/
echo += "<h2>Побитовая операция правого сдвига</h2>";
echo += "<p>Если Javascript, применя обычные арифметические операции работают с типом <i>Numeber</i>, как другие языки с <i>Float</i>, то его бинарные операции  вполне предсказуемо работают с <i>Numeber</i> также, как они работает с  <i>Integer</i> в С, то есть как с числом одиной точности — как с 32-битным числом со знаковым битом. Поэтому, чтобы сравнить эти два способа,  нам придется уменьшить размеры нашего «шахматного поля»(в легенде же так было?) до подходящих нам размеров — размером 1х31, и включим таймеры для сравнения скорости подсчета. Также можно попробовать сравнить с другими способами вычисления: умножение на двойку и возведение двойки в степень<sup>i</sup>. Для того, чтобы данные получились более достовеными, каждую из операций проведем по десять раз подряд. Чтобы не вызывать задержки на рендер текста, отключим вывод ";
chessboardSize = 31;

//********************************************************
echo += "<h3>Сложение</h3>";
timerStart = performance.now();
for (t = 1; t <= 100; t = t + 1) {
    j = 1;
    for (i = 1; i <= chessboardSize && j <= limit; i = i + 1) {
        j = j + j;
        //    echo += '<br>' + i + ') ' + j  ;
    }
}
timerStop = performance.now() - timerStart;
echo += "<p>Время забега: " + Math.round(timerStop * 10000) / 10000 + '</p>';

//********************************************************
echo += "<h3>Побитовый сдвиг</h3>";
timerStart = performance.now();
for (t = 1; t <= 100; t = t + 1) {
    j = 1;
    for (i = 1; i < chessboardSize; i = i + 1) {
        j = j << 1;
        //        echo += i + ') ' + j + '<br>';
    }
}
timerStop = performance.now() - timerStart;
echo += "<p>Время забега: " + Math.round(timerStop * 10000) / 10000 + '</p>';

//********************************************************
echo += "<h3>Умножение на два</h3>";
timerStart = performance.now();
for (t = 1; t <= 100; t = t + 1) {
    j = 1;
    for (i = 1; i < chessboardSize; i = i + 1) {
        j = j * 2;
        //        echo += i + ') ' + j + '<br>';
    }
}
timerStop = performance.now() - timerStart;
echo += "<p>Время забега: " + Math.round(timerStop * 10000) / 10000 + '</p>';

//********************************************************
echo += "<h3>Возведение в степень</h3>";
timerStart = performance.now();
for (t = 1; t <= 100; t = t + 1) {
    j = 1;
    for (i = 1; i < chessboardSize; i = i + 1) {
        j = Math.pow(2, i);
        //        echo += i + ') ' + j + '<br>';
    }
}
timerStop = performance.now() - timerStart;
echo += "<p>Время забега: " + Math.round(timerStop * 10000) / 10000 + '</p>';

//********************************************************
echo += "<h3><small>И на сдачу внеконкурсное выступление:</small><br> Линейно-рекурсивная функция</h3>";
echo += "<p>Попробуем еще один способ, исторически JavaScript прежде всего является функциональным языком программирования и, насколько я знаю, изначально задумывался скриптовым языком браузера для внутренних нужд приложения,  неким аналогом Emacs Lisp в одноименном редакторе  или AutoLISP в AutoCAD, но потом в угоду коньюктуры рынка преобрел свои ООП-черты. Но свои возможности фукционального языка программирования не потерял, хотя об этом все забыли на долгие годы. Сейчас внимание к функциональным языкам программирования возвращаются, во многом именно благодаря JavaScript — функциональный подход имеет массу преимуществ как в плане разработки и тестирования, так и в плане дальнейшей поддержки кода и его безопасности в целом. Так почему бы не попробовать эти возможности?</p>";

function chessboard (chessboardSize, limit) {                          // Передаем в функцию размеры нашего поля
    function iter(cnt, chessboardSize, limit, onField, output) {       // Объявляем функцию-итератор, она будет вызывать 
        if (cnt < chessboardSize || chessboardSize > 64 || onField >= limit ) {   
            onField = onField * 2;                                     // себя сама, пока не счетчик не станет больше 
            cnt = cnt + 1;                                             // шахматной доски. На каждой итерации счетчик 
            // output = cnt + ') ' + onField + '<br>';                 // растен на единицу.
            iter(cnt, chessboardSize, limit, onField, output);         // Рекурсивыный вызов итератора самим себя.    
        }
        return output;                                                  // Розвращаем новое значение "родительской" функции 
    }                                                                   // (первого функции порядка);
    return iter(1, chessboardSize, limit, 1, '');                       // Возвращаем значение функции в точку ее вызова
}
echo += "Вот код самой функции: <pre>" + chessboard + "</pre>";

timerStart = performance.now();
for (t = 1; t <= 100; t = t + 1) {
    chessboard(chessboardSize);
}
timerStop = performance.now() - timerStart;


echo += "<p>Время забега: " + Math.round(timerStop * 10000) / 10000 + '</p>';
echo += "<p>Честно говоря, бы уверен, что рекусивная функция будет отставать от императивного подхода по скорости, но, как оказалось, результаты вполне сравнимы с императивными способами организации цикла. Но даже это тут не главное. В отличие от других подходов, реализация даже такого простого цикла при помощи подхода функционального программирования, демонстрирует  безопасность кода: </p>";

echo += "<p>функция получила две переменные, одно значение возвратила. При этом на нее не влияют никакие внешние факторы, глобальные переменные или параметры системы — она с ними просто не взаимодействует никаким способом, кроме того, который описан в ее интерфейсе, она самодостаточна и будет предсказуемо работать в любом другом месте кода. И кроме того, она не повлияла ни на какие существующие данные, а это значит, что она наверняка ничего не сломала своими действиями.  </p>";
echo += "В общем как-то так :)";
document.getElementById('out').innerHTML = echo;
